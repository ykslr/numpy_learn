# 入门教程

### 基础知识

NumPy的主要对象是同构多维数组。它是一个元素表（通常是数字），所有类型都相同，由非负整数元组索引。在 NumPy 中维度（dimensions）称为 **轴（axes）** 。

例如，3D空间中的点的坐标[1, 2, 1]具有一个轴。该轴有3个元素，所以我们说它的长度为3.在下图所示的例子中，数组有2个轴。第一轴的长度为2，第二轴的长度为3
```python
[[1., 0., 0.], [0., 1., 2.]]
```

**注意理解此处**：（以下是 yuankuosheng 的个人理解）
1. 轴代表的是维度，所以一维数组有一个轴，二维数组有两个轴，三维数组有三个轴，以此类推

2. 在上面的二维数组中，有2个轴。该数组是2行3列的，所有第一个轴的长度为2，第二个轴的长度为3。轴是指维度，在二维数组中，我们可以用行列来分别表示2个轴，所以轴的长度即为行列的长度。以此类推到多维数组中。

NumPy 的数组类被称为 ndarray。它也被别名所知 array。请注意，numpy.array这与标准Python库类不同array.array，后者只处理一维数组并提供较少的功能。ndarray对象更重要的属性是：

* ndarray.ndim - 数组的轴（维度）的个数。在Python世界中，维度的数量被称为rank。

* ndarray.shape - 数组的维度。这是一个整数的元组，表示每个维度中数组的大小。对于有 n 行和 m 列的矩阵，shape 将是 (n,m)。因此，shape 元组的长度就是rank或维度的个数 ndim。

* ndarray.size - 数组元素的总数。这等于 shape 的元素的乘积。

* ndarray.dtype - 一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外NumPy提供它自己的类型。例如numpy.int32、numpy.int16和numpy.float64。

* ndarray.itemsize - 数组中每个元素的字节大小。例如，元素为 float64 类型的数组的 itemsize 为8（=64/8），而 complex32 类型的数组的 itemsize 为4（=32/8）。它等于 ndarray.dtype.itemsize 。

* ndarray.data - 该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引访问数组中的元素。

```python
>>> import numpy as np
>>> a = np.arange(15).reshape(3, 5)
>>> a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

>>> a.shape
(3, 5)
# 输出结果的长度为2，表示该数组有2个轴
# 第一个轴的长度为3，第二个轴的长度为5

>>> a.ndim  # 输出轴的个数
2
>>> a.dtype.name  # 输出数据类型
'int64'
>>> a.itemsize  # 输出数组中每个元素的字节大小
8
>>> a.size  # 输出元素的总数
15
>>> type(a)  # 输出a的类型
<type 'numpy.ndarray'>
```

### 数组创建

##### 使用 array 函数从常规 Python 列表或元组中创建数组

该方法得到的数组的类型是从 Python 列表中元素的类型推导出来的

```python
>>> import numpy as np
>>> a = np.array([2, 3, 4])
>>> a
array([2, 3, 4])
>>> a.dtype.name
'int64'
>>> b = np.array([1.2, 3.5, 5.1])
>>> b.dtype.name
'float64'
```

`arrya` 函数接收列表或元组作为参数，而不是多个数字

```python
>>> a = np.array(1, 2, 3, 4)  # 错误
>>> a = np.array([1, 2, 3, 4])  # 正确
```

`array` 还可以将序列的序列转换成二维数组，将序列的序列的序列转换成三维数组，等等

```python
>>> b = np.array([(1.5, 2, 3), (4, 5, 6)])
>>> b
array([[1.5, 2., 3.],
       [4.,  5., 6.]])
```

也可以在创建时显式指定数组的类型：

```python
>>> c = np.array([ [1,2], [3,4] ], dtype=complex )
array([[1.+0.j, 2.+0.j],
       [3.+0.j, 4.+0.j]])
```

##### 创建元素内容未知，大小（维度）已知的数组

通常，数组的元素最初是未知的，但它的大小是已知的。因此，NumPy提供了几个函数来创建具有初始占位符内容的数组。这就减少了数组增长的必要，因为数组增长的操作花费很大。

函数 `zeros` 创建一个由0组成的数组，函数 `ones` 创建一个由1组成的数组，函数 `empty` 创建一个数组，其初始内容是随机的，取决于内存的状态。默认情况下，创建的数组的 dtype 是 float64 类型的。

```python
>>> np.zeros( (3,4) )
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])

>>> np.ones( (2,3,4), dtype=np.int16)
array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],
       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]], dtype=int16)

>>> np.empty( (2,3) ) 
array([[  3.73603959e-262,   6.02658058e-154,   6.55490914e-260],
       [  5.30498948e-313,   3.14673309e-307,   1.00000000e+000]])
```

##### 根据范围和步长创建数组

为了创建数字组成的数组，NumPy 提供了一个类似于 `range` 的函数，该函数返回数组而不是列表。

```python
>>> np.arange(10, 30 ,5)  # 大于等于10且小于30，步长为5
array([10, 15, 20, 25])

>>> np.arange(0, 2, 0.3)  # 大于等于0且小于2，步长为0.3
array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])
```

##### 根据范围和元素总数创建数组

当 `arange` 与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用`linspace` 函数来接收我们想要的元素数量的函数，而不是步长（step）：

```python
>>> from numpy import pi
>>> np.linspace(0, 2, 9)  # 大于等于0且小于2，生成9个数
array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])

>>> np.linspace(0, 2*pi, 100) # 大于等于0且小于2*pi，生成100个数
>>> f = np.sin(x)
```

##### 其它的API

```
zeros_like,  ones_like,  empty_like, 
numpy.random.mtrand.RandomState.rand,
numpy.random.mtrand.RandomState.randn,
fromfunction,  fromfile
```

### 打印数组

当您打印数组时，NumPy 以与嵌套列表类似的方式显示它，但具有以下布局：

* 最后一个轴从左到右打印

* 倒数第二个从上到下打印

* 其余部分也从上到下打印，每个切片用空行分隔

* 然后将一维数组打印为行，将二维数据打印为矩阵，将三维数据打印为矩数组表

```python
>>> a = np.arange(6)  # 一维数组
>>> print(a)
[0 1 2 3 4 5]

>>> b = np.arange(12).reshape(4,3)  # 二维数组
>>> print(b)
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

>>> c = np.arange(24).reshape(2, 3, 4)  # 三维数组
>>> print(c)
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]
 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
```

如果数组太大而无法打印，NumPy 会自动跳过数组的中心部分并仅打印角点：

```python
>>> print(np.arange(10000))
[   0    1    2 ... 9997 9998 9999]

>>> print(np.arange(10000).reshape(100,100))
[[   0    1    2 ...   97   98   99]
 [ 100  101  102 ...  197  198  199]
 [ 200  201  202 ...  297  298  299]
 ...
 [9700 9701 9702 ... 9797 9798 9799]
 [9800 9801 9802 ... 9897 9898 9899]
 [9900 9901 9902 ... 9997 9998 9999]]
```

要禁用此行为并强制 NumPy 打印整个数组，可以使用更改打印选项 `set_printoptions`

```python
>>> np.set_printoptions(threshold=sys.maxsize) 
```

### 基本操作

数组上的算术运算符会应用到 **元素** 级别。NumPy 会给计算结果创建一个新的数组。

```python
>>> a = np.array([20, 30, 40, 50])
>>> b = np.arange(4)
>>> b
array([0, 1, 2, 3])
>>> c = a - b   # 相应的元素相减
>>> c
array([20, 29, 38, 47])
>>> b**2  # 相应的元素平方
array([0, 1, 4, 9], dtype=int32)
>>> 10 * np.sin(a)
array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])
>>> a < 35
array([ True,  True, False, False])
```

与许多矩阵语言不同，乘积运算符 `*` 在 NumPy 数组中按元素进行运算。矩阵乘积可以使用 `@` 运算符（在python> = 3.5中）或 `dot` 函数或方法执行：

```python
>>> A = np.array( [[1,1], [0,1]] )
>>> B = np.array( [[2,0], [3,4]] )
>>> A * B        # 元素乘积
array([[2, 0],
       [0, 4]])
>>> A @ B        # 矩阵乘积
array([[5, 4],
       [3, 4]])
>>> A.dot(B)     # 矩阵乘积的另一种方法
array([[5, 4],
       [3, 4]])
```

某些操作（例如 += 和 *=）会更直接更改被操作的矩阵数组而不会创建新矩阵数组。

```python
>>> a = np.ones((2,3), dtype=int)
>>> print(a)
array([[1, 1, 1],
       [1, 1, 1]])
>>> b = np.random.random((2,3))
>>> print(b)
[[0.04492895 0.70185398 0.87929813]
 [0.1214734  0.84655295 0.13559189]]

>>> a *= 3
>>> print(a)
[[3 3 3]
 [3 3 3]]

>>> b += a
>>> print(b)
[[3.04492895 3.70185398 3.87929813]
 [3.1214734  3.84655295 3.13559189]]

>>> a += b
Traceback (most recent call last):
...
numpy.core._exceptions.UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int32') with casting rule 'same_kind'
```

当使用不同类型的数组进行操作时，结果数组的类型对应于更一般或更精确的数组（称为向上转换的行为）。

```python
>>> a = np.ones(3, dtype=np.int32)
>>> b = np.linspace(0, np.pi, 3)
>>> b.dtype.name
'float64'
>>> c = a + b
>>> c
array([ 1.        ,  2.57079633,  4.14159265])
>>> c.dtype.name
'float64'
>>> d = np.exp(c * 1j)
>>> d
array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
       -0.54030231-0.84147098j])
>>> d.dtype.name
'complex128'
```

许多一元操作，例如计算数组中所有元素的总和，都是作为 ndarray 类的方法实现的

```python
>>> a = np.random.random((2, 3))
>>> a
array([[ 0.18626021,  0.34556073,  0.39676747],
       [ 0.53881673,  0.41919451,  0.6852195 ]])
>>> a.sum()
2.5718191614547998
>>> a.min()
0.1862602113776709
>>> a.max()
0.6852195003967595
```

默认情况下，这些操作适用于数组，就像它是一个数字列表一样，无论其形状如何。但是，通过指定 `axis` 参数，您可以沿数组的指定轴应用操作：

```python
>>> b = np.arange(12).reshape(3, 4)
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>>
>>> b.sum(axis=0)        # 每一列的和
array([12, 15, 18, 21])
>>>
>>> b.min(axis=1)        # 每一行的最小值
array([0, 4, 8])
>>>
>>> b.cumsum(axis=1)     # 每一行的累加
array([[ 0,  1,  3,  6],
       [ 4,  9, 15, 22],
       [ 8, 17, 27, 38]], dtype=int32)
```

### 通函数

NumPy 提供熟悉的数学函数，例如 `sin`，`cos` 和 `exp`。在 NumPy 中，这些被称为“通函数”（ufunc）。在NumPy中，这些函数在数组上按元素进行运算，产生一个数组作为输出。

```python
>>> B = np.arange(3)
>>> B
array([0, 1, 2])
>>> np.exp(B)
array([ 1.        ,  2.71828183,  7.3890561 ])
>>> np.sqrt(B)
array([ 0.        ,  1.        ,  1.41421356])
>>> C = np.array([2., -1., 4.])
>>> np.add(B, C)
array([ 2.,  0.,  6.])
```

##### 其它的通函数
```python
all,  any,  average,  ceil,  clip,
floor, max, mean, min, round, sort,
std, sum, where,  等等
```

### 索引、切片和迭代

一维的数组可以进行索引、切片和迭代操作的，就像列表和其他Python序列类型一样。
```python
>>> a = np.arange(10)**3
>>> a
array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])
>>> a[2]
8
>>> a[2:5]
array([ 8, 27, 64])
>>> a[:6:2] = -1000  # 从0到6的位置，偶数项为-1000
>>> a
array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])
>>> a[ : :-1]  # 将a倒序
array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])
>>> for i in a:
...     print(i**(1/3.))
...
nan
1.0
nan
3.0
nan
5.0
6.0
7.0
8.0
9.0
```

多维的数组每个轴可以有一个索引。这些索引以逗号​​分隔的元组给出：

```python
>>> def f(x,y):
...     return 10*x+y
...
>>> b = np.fromfunction(f,(5,4),dtype=int)
>>> b
array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23],
       [30, 31, 32, 33],
       [40, 41, 42, 43]])
>>> b[2, 3]
23
>>> b[0:5, 1]
array([1, 11, 21, 31, 41])
>>> b[:, 1]
array([1, 11, 21, 31, 41])
>>> b[1:3, :]
array([[10, 11, 12, 13],
       [20, 21, 22, 23]])
```

当提供的索引少于轴的数量时，缺失的索引被认为是完整的切片:

```python
>>> b[-1]
array([40, 41, 42, 43])
```

`b[i]` 方括号中的表达式 `i` 被视为后面紧跟着 `:` 的多个实例，用于表示剩余轴。NumPy也允许你使用三个点写为 `b[i,...]`。

三个点（ `...` ）表示产生完整索引元组所需的冒号。例如，如果 `x` 是rank为5的数组（即，它具有5个轴），则：

* x[1,2,...] 相当于 x[1,2,:,:,:]

* x[...,3] 等效于 x[:,:,:,:,3]

* x[4,...,5,:] 等效于 x[4,:,:,5,:]

```python
>>> c = np.array( [[[  0,  1,  2],   # 一个三维的数组
...                 [ 10, 12, 13]],
...                [[100,101,102],
...                 [110,112,113]]])
>>> c.shape
(2, 2, 3)
>>> c[1, ...]  # 输出第一个轴index为1的所有数据，相当于c[1,:,:]
array([[100, 101, 102],
       [110, 112, 113]])
>>> c[...,2]  # 输出第三个轴index为2的所有数据，相当于c[:,:,2]
array([[  2,  13],
       [102, 113]])
```

对多维数组进行 **迭代（Iterating）** 是相对于第一个轴完成的：

```python
>>> for row in b:
...    print(row)
...
[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
[30 31 32 33]
[40 41 42 43]
```

但是，如果想要对数组中的每个元素执行操作，可以使用 `flat`属性，该属性是数组的所有元素的迭代器：

```python
>>> for element in b.flat:
...    print(element)
...
0
1
2
3
10
11
12
13
20
21
22
23
30
31
32
33
40
41
42
43
```

### 形状操纵

##### 改变数组的形状

一个数组的形状是由每个轴的元素数量决定的：

```python
>>> a = np.floor(10*np.random.random((3,4)))
>>> a
array([[ 2.,  8.,  0.,  6.],
       [ 4.,  5.,  1.,  1.],
       [ 8.,  9.,  3.,  6.]])
>>> a.shape
(3, 4)
```

可以使用各种命令更改数组的形状。请注意，以下三个命令都返回一个修改后的数组，但不会更改原始数组：

```python
>>> a.ravel()
array([ 2.,  8.,  0.,  6.,  4.,  5.,  1.,  1.,  8.,  9.,  3.,  6.])
>>> a.reshape(6,2)
array([[ 2.,  8.],
       [ 0.,  6.],
       [ 4.,  5.],
       [ 1.,  1.],
       [ 8.,  9.],
       [ 3.,  6.]])
>>> a.T
array([[ 2.,  4.,  8.],
       [ 8.,  5.,  9.],
       [ 0.,  1.,  3.],
       [ 6.,  1.,  6.]])
>>> a.T.shape
(4, 3)
>>> a.shape
(3, 4)
```

`ndarray.resize` 方法会修改数组本身：

```python
>>> a
array([[ 2.,  8.,  0.,  6.],
       [ 4.,  5.,  1.,  1.],
       [ 8.,  9.,  3.,  6.]])
>>> a.resize((2,6))
>>> a
array([[ 2.,  8.,  0.,  6.,  4.,  5.],
       [ 1.,  1.,  8.,  9.,  3.,  6.]])
```

##### 将不同数组堆叠在一起

几个数组可以沿不同的轴堆叠在一起，例如：

```python
>>> a = np.floor(10*np.random.random((2,2)))
>>> a
array([[ 8.,  8.],
       [ 0.,  0.]])
>>> b = np.floor(10*np.random.random((2,2)))
>>> b
array([[ 1.,  8.],
       [ 0.,  4.]])
>>> np.vstack((a,b))
array([[ 8.,  8.],
       [ 0.,  0.],
       [ 1.,  8.],
       [ 0.,  4.]])
>>> np.hstack((a,b))
array([[ 8.,  8.,  1.,  8.],
       [ 0.,  0.,  0.,  4.]])
```

函数 `column_stack` 将一个1维数组作为2维数组的列合并在一起。相当于只用于2维数组的 `hstack` 函数

```python
>>> from numpy import newaxis
>>> np.column_stack((a,b))     # 对2维数组的操作
array([[ 8.,  8.,  1.,  8.],
       [ 0.,  0.,  0.,  4.]])
>>> a = np.array([4.,2.])
>>> b = np.array([3.,8.])
>>> np.column_stack((a,b))     # 对两个1维数组的操作，合并成2维数组
array([[ 4., 3.],
       [ 2., 8.]])
>>> np.hstack((a,b))           # 跟该函数的结果是不同的
array([ 4., 2., 3., 8.])
>>> a[:,newaxis]               # 添加一个轴，将1维数组变为2维
array([[ 4.],
       [ 2.]])
>>> np.column_stack((a[:,newaxis],b[:,newaxis])) # 对两个2维数组的操作，结果依然是2维数组
array([[ 4.,  3.],
       [ 2.,  8.]])
>>> np.hstack((a[:,newaxis],b[:,newaxis]))   # 和该函数对2维数组的操作结果相同
array([[ 4.,  3.],
       [ 2.,  8.]])
```

另一方面，函数 `ma.row_stack` 等效 `vstack` 于任何输入数组。通常，对于具有两个以上维度的数组， `hstack` 沿其第二轴堆叠，`vstack` 沿其第一轴堆叠，`concatenate` 允许使用可选参数来给出堆叠应发生的轴的编号。

##### 注意

更复杂的，`r_` 和 `c_` 可以通过在一个轴上堆叠数字来创建数组，他们还允许使用范围操作符（"`:`"）

```python
>>> np.r_[1:4, 0, 4]
array([1, 2, 3, 0, 4])
```

当使用数组作为`r_` 和 `c_`的参数时，这两个函数分别相当于 `vstack` 和 `hstack` 函数默认的作用，但允许使用可选参数给出要连接的轴的编号。

##### 将一个数组拆分成几个较小的数组

使用 `hsplit`，可以沿数组的水平轴拆分数组，方法是指定要返回的形状相等的数组的数量，或者指定应该在其之后进行分割的列：

```python
>>> a = np.floor(10*np.random.random((2,12)))
>>> a
array([[ 9.,  5.,  6.,  3.,  6.,  8.,  0.,  7.,  9.,  7.,  2.,  7.],
       [ 1.,  4.,  9.,  2.,  2.,  1.,  0.,  6.,  2.,  2.,  4.,  0.]])
>>> np.hsplit(a,3)   # 分成3个
[array([[ 9.,  5.,  6.,  3.],
       [ 1.,  4.,  9.,  2.]]), array([[ 6.,  8.,  0.,  7.],
       [ 2.,  1.,  0.,  6.]]), array([[ 9.,  7.,  2.,  7.],
       [ 2.,  2.,  4.,  0.]])]
>>> np.hsplit(a,(3,4))   # 在第三列和第四列分割
[array([[ 9.,  5.,  6.],
       [ 1.,  4.,  9.]]), array([[ 3.],
       [ 2.]]), array([[ 6.,  8.,  0.,  7.,  9.,  7.,  2.,  7.],
       [ 2.,  1.,  0.,  6.,  2.,  2.,  4.,  0.]])]
```

`vsplit` 沿垂直轴分割，并 `array_split` 允许指定要分割的轴。

### 拷贝和视图

当计算和操作数组时，有时会将数据复制到新数组中，有时则不会。这通常是初学者混淆的根源。有三种情况：

##### 完全不复制

简单分配不会复制数组对象或其数据

```python
>>> a = np.arange(12)
>>> b = a            # 不会产生新的对象
>>> b is a           # a 和 b 是同一个数组的不同的名字
True
>>> b.shape = 3,4    # 使用 b 改变 shape
>>> a.shape          # 使用 a 查看 shpae，同样发生了变化
(3, 4)
```

Python 将可变对象作为引用传递，因此函数调用不会复制

```python
>>> def f(x):
...    print(id(x))
...
>>> id(a)  # id 是对象独有的身份证号
148293216
>>> f(a)
148293216
```

##### 视图或浅拷贝

不同的数组对象可以共享内存中相同的数据。`view` 函数创建一个查看同一数据的新数组对象

```python
>>> c = a.view()
>>> c is a
False
>>> c.base is a                        # c 是 a 对象拥有的数据的一个视图
True
>>> c.flags.owndata
False
>>>
>>> c.shape = 2,6                      # 通过c修改shape, a的不会发生变化
>>> a.shape
(3, 4)
>>> c[0,4] = 1234                      # 通过c修改数据，a的会发生变化
>>> a
array([[   0,    1,    2,    3],
       [1234,    5,    6,    7],
       [   8,    9,   10,   11]])
```

切片数组会返回一个视图：

```python
>>> s = a[ : , 1:3]     # s 是 a 的第1和第2列
>>> s[:] = 10           # s 是 a 对象拥有的数据的一个视图，这同时改变了a的数据
>>> a
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
```

##### 深拷贝

`copy` 方法生成数组对象及其数据的完整副本

```python
>>> d = a.copy()                          # 复制完整的a
>>> d is a
False
>>> d.base is a                           # d 跟 a 没有任何关系
False
>>> d[0,0] = 9999
>>> a
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
```

有时，如果不再需要原始数组，则应在切片后调用 copy。例如，假设a是一个巨大的中间结果，最终结果b只包含a的一小部分，那么在用切片构造b时应该做一个深拷贝：

```python
>>> a = np.arange(int(1e8))
>>> b = a[:100].copy()
>>> del a  # 可以释放a占用的所有空间

# 如果改为使用 b = a[:100]，由于b是a浅拷贝而来，所以即使执行 del a, 数据也会在内存中持久存在。
```
