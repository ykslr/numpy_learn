# 入门教程

### 基础知识

NumPy的主要对象是同构多维数组。它是一个元素表（通常是数字），所有类型都相同，由非负整数元组索引。在 NumPy 中维度（dimensions）称为 **轴（axes）** 。

例如，3D空间中的点的坐标[1, 2, 1]具有一个轴。该轴有3个元素，所以我们说它的长度为3.在下图所示的例子中，数组有2个轴。第一轴的长度为2，第二轴的长度为3
```python
[[1., 0., 0.], [0., 1., 2.]]
```

**注意理解此处**：（以下是 yuankuosheng 的个人理解）
1. 轴代表的是维度，所以一维数组有一个轴，二维数组有两个轴，三维数组有三个轴，以此类推

2. 在上面的二维数组中，有2个轴。该数组是2行3列的，所有第一个轴的长度为2，第二个轴的长度为3。轴是指维度，在二维数组中，我们可以用行列来分别表示2个轴，所以轴的长度即为行列的长度。以此类推到多维数组中。

NumPy 的数组类被称为 ndarray。它也被别名所知 array。请注意，numpy.array这与标准Python库类不同array.array，后者只处理一维数组并提供较少的功能。ndarray对象更重要的属性是：

* ndarray.ndim - 数组的轴（维度）的个数。在Python世界中，维度的数量被称为rank。

* ndarray.shape - 数组的维度。这是一个整数的元组，表示每个维度中数组的大小。对于有 n 行和 m 列的矩阵，shape 将是 (n,m)。因此，shape 元组的长度就是rank或维度的个数 ndim。

* ndarray.size - 数组元素的总数。这等于 shape 的元素的乘积。

* ndarray.dtype - 一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外NumPy提供它自己的类型。例如numpy.int32、numpy.int16和numpy.float64。

* ndarray.itemsize - 数组中每个元素的字节大小。例如，元素为 float64 类型的数组的 itemsize 为8（=64/8），而 complex32 类型的数组的 itemsize 为4（=32/8）。它等于 ndarray.dtype.itemsize 。

* ndarray.data - 该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引访问数组中的元素。

```python
>>> import numpy as np
>>> a = np.arange(15).reshape(3, 5)
>>> a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

>>> a.shape
(3, 5)
# 输出结果的长度为2，表示该数组有2个轴
# 第一个轴的长度为3，第二个轴的长度为5

>>> a.ndim  # 输出轴的个数
2
>>> a.dtype.name  # 输出数据类型
'int64'
>>> a.itemsize  # 输出数组中每个元素的字节大小
8
>>> a.size  # 输出元素的总数
15
>>> type(a)  # 输出a的类型
<type 'numpy.ndarray'>
```

### 数组创建

##### 使用 array 函数从常规 Python 列表或元组中创建数组

该方法得到的数组的类型是从 Python 列表中元素的类型推导出来的

```python
>>> import numpy as np
>>> a = np.array([2, 3, 4])
>>> a
array([2, 3, 4])
>>> a.dtype.name
'int64'
>>> b = np.array([1.2, 3.5, 5.1])
>>> b.dtype.name
'float64'
```

`arrya` 函数接收列表或元组作为参数，而不是多个数字

```python
>>> a = np.array(1, 2, 3, 4)  # 错误
>>> a = np.array([1, 2, 3, 4])  # 正确
```

`array` 还可以将序列的序列转换成二维数组，将序列的序列的序列转换成三维数组，等等

```python
>>> b = np.array([(1.5, 2, 3), (4, 5, 6)])
>>> b
array([[1.5, 2., 3.],
       [4.,  5., 6.]])
```

也可以在创建时显式指定数组的类型：

```python
>>> c = np.array([ [1,2], [3,4] ], dtype=complex )
array([[1.+0.j, 2.+0.j],
       [3.+0.j, 4.+0.j]])
```

##### 创建元素内容未知，大小（维度）已知的数组

通常，数组的元素最初是未知的，但它的大小是已知的。因此，NumPy提供了几个函数来创建具有初始占位符内容的数组。这就减少了数组增长的必要，因为数组增长的操作花费很大。

函数 `zeros` 创建一个由0组成的数组，函数 `ones` 创建一个由1组成的数组，函数 `empty` 创建一个数组，其初始内容是随机的，取决于内存的状态。默认情况下，创建的数组的 dtype 是 float64 类型的。

```python
>>> np.zeros( (3,4) )
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])

>>> np.ones( (2,3,4), dtype=np.int16)
array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],
       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]], dtype=int16)

>>> np.empty( (2,3) ) 
array([[  3.73603959e-262,   6.02658058e-154,   6.55490914e-260],
       [  5.30498948e-313,   3.14673309e-307,   1.00000000e+000]])
```

##### 根据范围和步长创建数组

为了创建数字组成的数组，NumPy 提供了一个类似于 `range` 的函数，该函数返回数组而不是列表。

```python
>>> np.arange(10, 30 ,5)  # 大于等于10且小于30，步长为5
array([10, 15, 20, 25])

>>> np.arange(0, 2, 0.3)  # 大于等于0且小于2，步长为0.3
array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])
```

##### 根据范围和元素总数创建数组

当 `arange` 与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用`linspace` 函数来接收我们想要的元素数量的函数，而不是步长（step）：

```python
>>> from numpy import pi
>>> np.linspace(0, 2, 9)  # 大于等于0且小于2，生成9个数
array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])

>>> np.linspace(0, 2*pi, 100) # 大于等于0且小于2*pi，生成100个数
>>> f = np.sin(x)
```

##### 其它的API

```
zeros_like,  ones_like,  empty_like, 
numpy.random.mtrand.RandomState.rand,
numpy.random.mtrand.RandomState.randn,
fromfunction,  fromfile
```

### 打印数组

当您打印数组时，NumPy 以与嵌套列表类似的方式显示它，但具有以下布局：

* 最后一个轴从左到右打印

* 倒数第二个从上到下打印

* 其余部分也从上到下打印，每个切片用空行分隔

* 然后将一维数组打印为行，将二维数据打印为矩阵，将三维数据打印为矩数组表

```python
>>> a = np.arange(6)  # 一维数组
>>> print(a)
[0 1 2 3 4 5]

>>> b = np.arange(12).reshape(4,3)  # 二维数组
>>> print(b)
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

>>> c = np.arange(24).reshape(2, 3, 4)  # 三维数组
>>> print(c)
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]
 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
```

如果数组太大而无法打印，NumPy 会自动跳过数组的中心部分并仅打印角点：

```python
>>> print(np.arange(10000))
[   0    1    2 ... 9997 9998 9999]

>>> print(np.arange(10000).reshape(100,100))
[[   0    1    2 ...   97   98   99]
 [ 100  101  102 ...  197  198  199]
 [ 200  201  202 ...  297  298  299]
 ...
 [9700 9701 9702 ... 9797 9798 9799]
 [9800 9801 9802 ... 9897 9898 9899]
 [9900 9901 9902 ... 9997 9998 9999]]
```

要禁用此行为并强制 NumPy 打印整个数组，可以使用更改打印选项 `set_printoptions`

```python
>>> np.set_printoptions(threshold=sys.maxsize) 
```

### 基本操作

数组上的算术运算符会应用到 **元素** 级别。NumPy 会给计算结果创建一个新的数组。

```python
>>> a = np.array([20, 30, 40, 50])
>>> b = np.arange(4)
>>> b
array([0, 1, 2, 3])
>>> c = a - b   # 相应的元素相减
>>> c
array([20, 29, 38, 47])
>>> b**2  # 相应的元素平方
array([0, 1, 4, 9], dtype=int32)
>>> 10 * np.sin(a)
array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])
>>> a < 35
array([ True,  True, False, False])
```

与许多矩阵语言不同，乘积运算符 `*` 在 NumPy 数组中按元素进行运算。矩阵乘积可以使用 `@` 运算符（在python> = 3.5中）或 `dot` 函数或方法执行：

```python
>>> A = np.array( [[1,1], [0,1]] )
>>> B = np.array( [[2,0], [3,4]] )
>>> A * B        # 元素乘积
array([[2, 0],
       [0, 4]])
>>> A @ B        # 矩阵乘积
array([[5, 4],
       [3, 4]])
>>> A.dot(B)     # 矩阵乘积的另一种方法
array([[5, 4],
       [3, 4]])
```

某些操作（例如 += 和 *=）会更直接更改被操作的矩阵数组而不会创建新矩阵数组。

```python
>>> a = np.ones((2,3), dtype=int)
>>> print(a)
array([[1, 1, 1],
       [1, 1, 1]])
>>> b = np.random.random((2,3))
>>> print(b)
[[0.04492895 0.70185398 0.87929813]
 [0.1214734  0.84655295 0.13559189]]

>>> a *= 3
>>> print(a)
[[3 3 3]
 [3 3 3]]

>>> b += a
>>> print(b)
[[3.04492895 3.70185398 3.87929813]
 [3.1214734  3.84655295 3.13559189]]

>>> a += b
Traceback (most recent call last):
...
numpy.core._exceptions.UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int32') with casting rule 'same_kind'
```

当使用不同类型的数组进行操作时，结果数组的类型对应于更一般或更精确的数组（称为向上转换的行为）。

```python
>>> a = np.ones(3, dtype=np.int32)
>>> b = np.linspace(0, np.pi, 3)
>>> b.dtype.name
'float64'
>>> c = a + b
>>> c
array([ 1.        ,  2.57079633,  4.14159265])
>>> c.dtype.name
'float64'
>>> d = np.exp(c * 1j)
>>> d
array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
       -0.54030231-0.84147098j])
>>> d.dtype.name
'complex128'
```

许多一元操作，例如计算数组中所有元素的总和，都是作为 ndarray 类的方法实现的

```python
>>> a = np.random.random((2, 3))
>>> a
array([[ 0.18626021,  0.34556073,  0.39676747],
       [ 0.53881673,  0.41919451,  0.6852195 ]])
>>> a.sum()
2.5718191614547998
>>> a.min()
0.1862602113776709
>>> a.max()
0.6852195003967595
```

默认情况下，这些操作适用于数组，就像它是一个数字列表一样，无论其形状如何。但是，通过指定 `axis` 参数，您可以沿数组的指定轴应用操作：

```python
>>> b = np.arange(12).reshape(3, 4)
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>>
>>> b.sum(axis=0)        # 每一列的和
array([12, 15, 18, 21])
>>>
>>> b.min(axis=1)        # 每一行的最小值
array([0, 4, 8])
>>>
>>> b.cumsum(axis=1)     # 每一行的累加
array([[ 0,  1,  3,  6],
       [ 4,  9, 15, 22],
       [ 8, 17, 27, 38]], dtype=int32)
```
